&emsp;&emsp;在```XML```文件中，如果需要引用一个id，使用```@id/id_name```，  
&emsp;&emsp;如果需要定义一个id,使用```@+id/id_name```  
***

&emsp;&emsp;如果编译时，右下角显示```default activity not found```编译不了，
是因为```AndroidManifest.xml```文件没有声明app默认启动的```activity```,补上声明：  
```xml
<activity
        android:name=".MainActivity">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
 
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
</activity>
```
***


&emsp;&emsp;```XML```文件注释内容：  
> 注释以``` <!-- ```开始并以  
>  ```--> ```结束，  
> 例如 ```<!--注释内容-->。```  

&emsp;&emsp;快捷键：  
> ```Ctrl + O ```---重写方法  

# 第一个布局
```kotlin
class FirstActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        /**
         * setContentView给当前Activity加载一个布局
         * 所有的Activity都要在AndroidManifest.xml中注册才能生效
         */
        setContentView(R.layout.first_layout)

        /**
         * ： Button 将变量显示声明成Button类型
         * 通过findViewById获取在布局中定义的元素,
         * 返回的是一个继承自View的泛型对象，
         */
        val button1: Button = findViewById(R.id.button1)

        //setOnClickListener为按钮注册一个监听器
        //Activity本身就是一个context对象，故传入this
        button1.setOnClickListener {
            Toast.makeText(this,"you clicked Button 1",Toast.LENGTH_SHORT).show();
        }
    }
}
```
***

# Menu的使用
1. 在```res```文件夹下新建文件夹```menu```,右键```new -> Menu resource file```，新建一个```main.xml```文件。  
&emsp;&emsp;```item```标签创建菜单项，```android:id```指定标识符，```android:title```设置菜单项名字。  
```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <!--item标签创建具体的某一个菜单项-->
    <item
        android:id="@+id/add_item"
        android:title="Add" />
    <item
        android:id="@+id/remove_item"
        android:title="Remove" />
</menu>
```

2. 在```Activity```中，```Ctrl + O```重写方法```onCreateOptionMenu()```创建菜单，重写方法```onOptionsItemSelected```设置菜单项选中事件。  
```kotlin
//重写创建菜单
    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
//        return super.onCreateOptionsMenu(menu)
        //menuInflater实际上是 getMenuInflater()，这是kotlin的一个语法糖
        //getMenuInflater()方法得到一个menuInflater对象
        //inflate的第二个参数指定菜单项添加到哪一个Menu对象中
        //这里用onCreateOptionsMenu方法传入的menu参数
        menuInflater.inflate(R.menu.main,menu)
        //返回true允许创建的菜单显示出来，false则无法显示
        return true
    }

    //重写菜单响应事件
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
//        return super.onOptionsItemSelected(item)
        //这里的itemId实际上是getItemId()方法
        when(item.itemId){
            R.id.add_item -> Toast.makeText(this,"you clicked Add",Toast.LENGTH_SHORT).show()
            R.id.remove_item -> Toast.makeText(this,"you clicked Remove", Toast.LENGTH_SHORT).show()
        }
        return  true
    }
```
***

# Intent页面跳转
## 显示```Intent```:  
```kotlin
button1.setOnClickListener {
    //显示Intent
    //Intent第一个参数传入this即FirstActivity作为上下文
    //第二个参数传入想要启动的目标Activity
    //::表示把一个方法当作参数传递到另一个方法里使用
    //startActivity执行intent
    val intent = Intent(this,SecondActivity::class.java)
    startActivity(intent)
}
```

## 隐式```Intent```:  
1. 基本使用：  
&emsp;&emsp;在```XML```文件中配置相应隐式```Intent```的```Activity```，```<action>```标签指定响应名称，```<category>```
包含附加信息。```<action>```和```<category>```都能在```XML```中存在多个。  
&emsp;&emsp;```android.intent.category.DEFAULT```是默认的```category```,调用```startActivity```时会自动将这个```category```添加到
```Intent```中。  
&emsp;&emsp;```XML```中设置隐式至少要有一个```<action>```和一个```<category>```。  
```XML
<intent-filter>
        <action android:name="com.example.activitytest.ACTION_START"/>
        <action android:name="com.example.activitytest.TTYV"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="com.example.category.MY_CATEGORY"/>
        <category android:name="com.example.category.TTYV"/>
</intent-filter>
```

```kotlin
button1.setOnClickListener {
    val intent = Intent("com.example.activitytest.TTYV")
    intent.addCategory("com.example.category.MY_CATEGORY")
    startActivity(intent)
}
```

2. 其他使用：  
调用浏览器打开网页：  
> ```Intent.ACTION_VIEW```是系统的内置动作，其常量值是```android.intent.action.VIEW```  
```kotlin
val intent = Intent(Intent.ACTION_VIEW)
//Uri.parse()将字符串解析成Uri对象
//data即调用了Intent的setData()传入Rri
intent.data = Uri.parse("https://www.baidu.com")
startActivity(intent)
```

&emsp;&emsp;```<data>```标签的使用：  
> 注意这里配置当前```Activity```能够响应的```action```是```android.intent.action.VIE```，即常量值```Intent.ACTION_VIEW```。  
> ```android:scheme```指定协议必须是```https```，这样能够响应一个打开网页的```Intent```。  
```xml
<activity android:name=".ThirdActivity">
    <intent-filter tools:ignore="AppLinkUrlError">
        <action android:name="android.intent.action.VIEW"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:scheme="https"/>
    </intent-filter>
</activity>
```

```kotlin
val intent = Intent(Intent.ACTION_VIEW)
intent.data = Uri.parse("https://www.baidu.com")
startActivity(intent)
```
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Intent_01.png)

&emsp;&emsp;拨号： 
> ```data```指定协议是```tel```,号码是```10086```  
```kotlin
val intent = Intent(Intent.ACTION_DIAL)
intent.data = Uri.parse("tel:10086")
startActivity(intent)
```

## 向下一个Activity传递数据
&emsp;&emsp;在第一个```Activity```里：  
```kotlin
button1.setOnClickListener {
    val data = "第一个页面传递的数据"
    val intent = Intent(this,SecondActivity::class.java)
    //第一个参数是键，第二个参数是要传递的数据
    intent.putExtra("extra_data",data)
    startActivity(intent)
}
```
&emsp;&emsp;在第二个```Activity```里：  
```kotlin
//这里的intent实际上调用的是父类的getIntent()方法，
//该方法会获取用于启动SecondActivity的Intent,
//然后调用getStringExtra()方法并传入对应的键值来获取数据
//还有getIntExtra()、getBooleanExtra()
val extraData = intent.getStringExtra("extra_data")
Log.d("SecondActivity","传过来的数据是$extraData")
```

## 向上一个Activity传递数据
&emsp;&emsp;在第一个```Activity```里：  
> 通过```startActivityForResult```方法来启动第二个页面，重写```onActivityResult```方法获取返回的数据
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.first_layout)

    button1.setOnClickListener {
        val intent = Intent(this,SecondActivity::class.java)
        //startActivityForResult能够在Activity销毁时返回一个结果给上一个Activity
        //第二个参数是请求码，用于在之后的回调中判断数据的来源
        startActivityForResult(intent,1)
    }
}

//由于使用了startActivityForResult启动第二个页面
//在第二个页面被销毁后会回调上一个Activity的onActivityResult()方法
//这里重写onActivityResult方法得到返回的数据
//第一个参数是请求码
//第二个参数时处理结果
//第三个参数是携带返回数据的Intent
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    //这里使用when()语句是因为需要返回结果的页面可能有多个，
    //通过检查请求码来判断跳转到的是哪一个界面
    //根据resultCode判断处理结果是否成功
    //?.是经典语法糖，dart里也有左边为空返回Null，不为空调用右边方法
    when(requestCode){
        1 -> if(resultCode == Activity.RESULT_OK){
            val returnData = data?.getStringExtra("data_return")
            Log.d("FirstActivity","第一个页面获取到返回的数据：$returnData")
        }
    }
}
```

&emsp;&emsp;在第二个```Activity```里：  
> 通过```setResult```方法向上一个```Activity```返回数据。  
```kotlin
button2.setOnClickListener {
    //这里构建了一个intent,仅用于传递数据，没有指定意图
    val intent = Intent()
    intent.putExtra("data_return","这是第二个页面的数据")
    //setResult向上一个Activity返回数据
    //第一个参数返回处理结果，一般只用RESULT_OK或RESULT_CANCELED
    //第二个参数把带有数据的Intent传递回去
    setResult(Activity.RESULT_OK,intent)
    finish()
}
```

&emsp;&emsp;需要注意，如果是点击手机的Back键返回到上一个页面,数据是没法返回，所以需要在第二个页面重写点击Back键的事件```onBackPressed```。  
&emsp;&emsp;另外需要注释掉```super.onBackPressed()```，不然返回结果被固定成0 (RESULT_CANCELED)
```kotlin
override fun onBackPressed() {
//        super.onBackPressed()
    val intent = Intent()
    intent.putExtra("data_return","这是第二个页面点击返回键的数据")
    //setResult向上一个Activity返回数据
    //第一个参数返回处理结果，一般只用RESULT_OK或RESULT_CANCELED
    //第二个参数把带有数据的Intent传递回去
    setResult(Activity.RESULT_OK,intent)
    finish()
}
```
***

# Activity生命周期
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life.png)

## 直观感受生命周期  
### 1. 建立两个```Activity```，命名为```NormalActivity```和```DialogActivity```。  
**kotlin文件**  
```kotlin
class NormalActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_normal)
    }
}

class DialogActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_dialog)
    }
}
```

**布局XML文件**  
```xml
<!-->DialogActivity <-->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".DialogActivity">

    <TextView
        android:text="这是一个Dialog Activity"
        android:textAlignment="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>

<!-->NormalActivity <-->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".NormalActivity">

    <TextView
        android:text="这是一个正常的Activity"
        android:textAlignment="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

</LinearLayout>
```

### 2. 在```AndroidManifest.xml```文件中,修改```dialog```的```<activity>```标签。  
> 这里使用了一个```android:theme```属性，用于给当前```Activity```指定主题。  
> ```@style/Theme.AppCompat.Dialog```指定使用对话框式的主题。  
```xml
<activity android:name=".DialogActivity"
    android:theme="@style/Theme.AppCompat.Dialog">
</activity>
```

### 3. 修改主```Activity```。  
```kotlin
private val tag = "MainActivity"

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    Log.d(tag,"onCreate")

    setContentView(R.layout.first_layout)

    //绑定跳转到NormalActivity的按钮
    startNormalActivity.setOnClickListener {
        val intent = Intent(this,NormalActivity::class.java)
        startActivity(intent)
    }
    //绑定跳转到DialogActivity的按钮
    startDialogActivity.setOnClickListener {
        val intent = Intent(this,DialogActivity::class.java)
        startActivity(intent)
    }
}

override fun onStart() {
    super.onStart()
    Log.d(tag,"onStart")
}

override fun onResume() {
    super.onResume()
    Log.d(tag,"onResume")
}

override fun onPause() {
    super.onPause()
    Log.d(tag,"onPause")
}

override fun onStop() {
    super.onStop()
    Log.d(tag,"onStop")
}

override fun onDestroy() {
    super.onDestroy()
    Log.d(tag,"onDestroy")
}

override fun onRestart() {
    super.onRestart()
    Log.d(tag,"onRestart")
}

```

### 运行结果  
1. 进入到主```Activity```(这里是打开APP)：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_01.PNG)

2. 进入```NormalActivity```：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_02.PNG)

3. 从```NormalActivity```退回到主```Activity```：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_03.PNG)

4. 进入```DialogActivity```：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_04.PNG)

5. 从```DialogActivity```退回到主```Activity```：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_05.PNG)

6. 退出```Activity```：  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/life_06.PNG)

### ```Activity```被回收的情况  
&emsp;&emsp;当一个```Activity```进入停止状态，如果系统内存不足，是有可能被系统回收的。  
&emsp;&emsp;当在```AActivity```的基础上打开```BActivity```，```AActivity```由于内存不足被回收，此时点击Back键返回```AActivity```，
会执行```AActivity```的```onCreate()```方法，```AActivity```被重新创建了一次。  
&emsp;&emsp;如果```AActivity```保存了临时数据怎么办？  
&emsp;&emsp;解决方法：重写```onSaveInstanceState()```  

#### ```onSaveInstanceState()```  
&emsp;&emsp;该方法在```Activity```被回收前一定会被调用。  
```kotlin
//提供一个Bundle类型参数用于保存数据
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    val tempData = "临时保存的数据"
    outState.putString("data_key",tempData)
}

```
&emsp;&emsp;在```onCreate()```方法中取出被保存的数据。    
```kotlin
private val tag = "MainActivity"
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.first_layout)
    
    if(savedInstanceState != null){
        val tempData = savedInstanceState.getString("data_key")
        Log.d(tag,tempData)
    }
}
```

&emsp;&emsp;手机屏幕旋转，```Activity```也会经历一个重新创建的过程，这里通过旋转屏幕的方式来模拟内存不足的情况。  
&emsp;&emsp;除此之外，```Bundle```对象也能存放到```Intent```里。  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Bundle_01.PNG)



