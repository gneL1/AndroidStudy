 # 网络相关
## 一、 WebView
1. 修改布局界面  
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".WebviewTest">

    <WebView
        android:id="@+id/webView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

</LinearLayout>
```

2. 修改```WebviewTest```  
&emsp;&emsp;```WebView```的```getSettings()```方法可以设置一些浏览器的属性，调用```setJavaScriptEnabled()```方法让```WebView```支持```JavaScript```脚本。  
&emsp;&emsp;调用```WebView```的```setWebViewClient()```方法，传入一个```WebViewClient()```实例，当需要从一个网页跳转到另一个网页时，目标网页仍然在当前```WebView```中显示，而不是打开系统浏览器。  
```kotlin
class WebviewTest : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_webview_test)

        webView.settings.javaScriptEnabled
        webView.webViewClient = WebViewClient()
        webView.loadUrl("https://www.mooyuu.com/")
    }
}
```
3. 修改```AndroidManifest```  
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.internettest">

    <uses-permission android:name="android.permission.INTERNET"/>
    ......
```
<img src="https://github.com/gneL1/AndroidStudy/blob/master/photos/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/webview_1.png" width="400" height="680" align=center/>

***

## 二、HTTP访问网络
&emsp;&emsp;客户端向服务器发送一条HTTP请求，服务器收到请求之后返回一些数据给客户端，客户端再对这些数据进行解析和处理。  
### 1. HttpURLConnection
获取```HttoURLConnection```对象，需要创建一个```URL```对象，并传入目标的网络地址，然后调用```openConnection()```方法。  
```kotlin
val url = URL("https://cn.bing.com/")
val connection = url.openConnection() as HttpURLConnection
```

得到```HttpURLConnection```实例后，设置```HTTP```请求所使用的方法。常用的方法有两个：```GET```和```POST```。  
&emsp;&emsp;```GET```表示希望从服务器获取数据。  
&emsp;&emsp;```POST```表示希望提交数据给服务器。  
```kotlin
connection.requestMethod = "GET"
```

设置连接超时、读取超时的毫秒数等。  
```kotlin
connection.connectTimeout = 8000
connection.readTimeout = 8000
```

调用```getInputStream()```方法获取到服务器返回的输入流，对流进行读取。  
```kotlin
val input = conntction.inputStream
......
```

最后调用```disconnect()```方法将这个```HTTP```连接关闭。  
```kotlin
connection.disconnect()
```

* 修改布局文件  
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".HUCTest">
    
    <Button
        android:id="@+id/Btn_sendRequest"
        android:text="发送请求"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <TextView
            android:id="@+id/Tv_response"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"/>

    </ScrollView>
    
</LinearLayout>
```

* 修改```HUCTest```  
```kotlin
class HUCTest : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_h_u_c_test)

        Btn_sendRequest.setOnClickListener {
            sendRequestWithHttpURLConnection()
        }
    }

    /**
     * 首先开启一个子线程，在子线程里使用HttpURLConnection发出一条HTTP请求
     * 使用BufferedReader对服务器返回的流进行读取，并将结果传入showResponse()方法里，
     * 调用runOnUiThread()方法，在这个方法的Lambda表达式中进行操作，将返回的数据显示到界面上
     */
    private fun sendRequestWithHttpURLConnection(){
        //开启线程发起网络请求
        thread {
            var connection : HttpURLConnection? = null
            try {
                val response = StringBuilder()
                val url = URL("https://cn.bing.com/")
                connection = url.openConnection() as HttpURLConnection
                connection.connectTimeout = 8000
                connection.readTimeout = 8000
                val input = connection.inputStream

                //对获取到的流进行读取
                val reader = BufferedReader(InputStreamReader(input))
                reader.use {
                    reader.forEachLine {
                        response.append(it)
                    }
                }
                showResponse(response.toString())
            }catch (e : Exception){
                e.printStackTrace()
            }finally {
                connection?.disconnect()
            }
        }
    }

    private fun showResponse(response:String){
        runOnUiThread {
            //在这里进行UI操作，结果显示到界面上
            Tv_response.text = response
        }
    }

}
```

* 修改```AndroidManifest.xml```  
```xml
<uses-permission android:name="android.permission.INTERNET" />
```
<img src="https://github.com/gneL1/AndroidStudy/blob/master/photos/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HttpURLConnection.png" width="400" height="680" align=center/>

***

### 2. OkHttp
在```app/build.gradle```文件中添加包。  
```gradle
dependencies {
    ......
    implementation 'com.squareup.okhttp3:okhttp:4.7.2'
}
```

创建一个```OkHttpClient```实例。  
```kotlin
val client = OkHttpClient()
```

创建一个```Request```对象。  
```kotlin
val request = Request.Builder().
    .url("https://cn.bing.com/")
    .build()
```

调用```OkHttpClient```的```newCall()```方法来创建一个```Call```对象，调用它的```execute()```方法来发送请求并获取服务器返回的数据。  
```kotlin
val response = client.newCall(request).execute()
```

```Response```对象就是服务器返回的数据。  
```kotlin
val responseData = response.body?.string()
```

如果是发起一条```Post```请求，需要先构建一个```RequestBody```对象来存放待提交的参数。  
```kotlin
val requestBody = FormBody.Builder()
    .add("username","admin")
    .add("password","123456")
    .build()
```

然后在```Request.Builder```中调用一下```Post()```方法，并将```RequestBody```对象传入。  
```kotlin
val requestPost = Request.Builder()
    .url("https://cn.bing.com/")
    .post(requestBody)
    .build()
```

* 修改```OkHttpTest```  
```kotlin
class OkHttpTest : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_ok_http_test)
        Btn_sendRequest.setOnClickListener {
            sendRequestWithOkHttp()
        }
    }

    private fun sendRequestWithOkHttp(){
        thread {
            try {
                val client = OkHttpClient()
                val request = Request.Builder()
                    .url("https://cn.bing.com/")
                    .build()
                val response = client.newCall(request).execute()
                val responseData = response.body?.string()
                if (responseData != null){
                    showResponse(responseData)
                }
            }catch (e:Exception){
                e.printStackTrace()
            }
        }
    }

    private fun showResponse(response:String){
        runOnUiThread {
            //在这里进行UI操作，结果显示到界面上
            Tv_response.text = response
        }
    }
}
```
 
***

## 三、解析XML格式数据
&emsp;&emsp;搭建一个Web服务器，在这个服务器上提供一段```XML```文本，在程序里去访问这个服务器，再对得到的```XML```文本进行解析。  
&emsp;&emsp;何为服务器？通俗讲就是在一台计算机上，安装个服务器软件，这台计算机便可以称之为服务器，服务器软件和计算机本身的操作系统是两码事，计算机自身的操作系统可以为linux、Unix、Windows或者MacOS，同时服务软件也可以是Apache（PHP）、Tomcat(java/jsp)、IIS(asp)。  
&emsp;&emsp;PHP主要使用的是Apache服务器，主流的站点搭建组合为LAMP(Linux、Apache、MySQL、PHP)，Windows下的集成服务器软件为WAMP（Windows、Apache、MySQL、PHP）。另外，还有一些其它的PHP服务器软件，如德国的lighttpd，俄国的nginx。

* 搭建Apache服务器
参考[搭建介绍](https://github.com/gneL1/AndroidStudy/blob/master/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA.md)  

* 添加```XML```文件  
在```安装目录\htdocs\```文件夹下新建一个```get_data.xml```文件。  
```xml
<apps>
    <app>
        <id>1</id>
        <name>Google Maps</name>
        <version>1.0</version>
    </app>

    <app>
        <id>2</id>
        <name>Chrome</name>
        <version>2.1</version>
    </app>

    <app>
        <id>3</id>
        <name>Google Play</name>
        <version>2.3</version>
    </app>

</apps>
```
* 在浏览器访问```http://127.0.0.1/get_data.xml```，出现下图所示界面。  
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/Apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/apache_15.PNG)

### 1. Pull解析
1. 修改```XMLPull```文件  
```kotlin
class XMLPull : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_x_m_l_pull)

        Btn_xml_pull.setOnClickListener {
            sendRequestWithOkHttp()
        }
    }

    private fun sendRequestWithOkHttp(){
        thread {
            try {
                val client = OkHttpClient()

                /**
                 * 将HTTP请求的地址改为http://10.0.2.2/get_data.xml,
                 * 10.0.2.2对于模拟器来说就是计算机本机的IP地址
                 */
                val request = Request.Builder()
                    .url("http://10.0.2.2/get_data.xml")
                    .build()
                val response = client.newCall(request).execute()
                val responseData = response.body?.string()
                if (responseData != null){
                    parseXMLWithPull(responseData)
                }
            }catch (e :Exception){
                e.printStackTrace()
            }
        }
    }

    private fun parseXMLWithPull(xmlData:String){
        /**
         * 首先创建一个XmlPullParserFactory实例，借助这个实例得到xmlPullParser对象
         * 调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去，然后开始解析
         * 通过getEventType()方法得到当前的解析事件，然后在一个while循环中不断进行解析
         */
        try {
            val factory = XmlPullParserFactory.newInstance()
            val xmlPullParser = factory.newPullParser()
            xmlPullParser.setInput(StringReader(xmlData))
            var eventType = xmlPullParser.eventType
            var id = ""
            var name = ""
            var version = ""
            /**
             * 如果当前的解析事件不等于XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用next()方法获取下一个解析事件
             * 在while循环中，通过getName()方法获取当前节点的名字
             * 如果发现节点名等于id、name、或version，就调用nextText()方法获取节点内的具体内容
             * 每当解析完一个app节点，就将获取到的内容打印出来
             */
            while (eventType != XmlPullParser.END_DOCUMENT){
                val nodeName = xmlPullParser.name
                when(eventType){
                    //开始解析某个节点
                    XmlPullParser.START_TAG -> {
                        when(nodeName){
                            "id" -> id = xmlPullParser.nextText()
                            "name" -> name = xmlPullParser.nextText()
                            "version" -> version = xmlPullParser.nextText()
                        }
                    }
                    //完成某个节点的解析
                    XmlPullParser.END_TAG -> {
                        if ("app" == nodeName){
                            Log.d("XMLPull:","id : $id")
                            Log.d("XMLPull:","name : $name")
                            Log.d("XMLPull:","version : $version")
                        }
                    }
                }
                eventType = xmlPullParser.next()
            }
        }catch (e : Exception){
            e.printStackTrace()
        }
    }
}
```

2. 新增```network_config.xml```文件  
&emsp;&emsp;右键```res```目录 -> New -> Directroy，创建一个```xml```目录，右键```xml```目录 -> New -> File，创建一个```network_config.xml```文件，修改文件内容：    
```xml
<?xml version = "1.0" encoding = "utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted = "true">
        <trust-anchors>
            <certificates src = "system"/>
        </trust-anchors>
    </base-config>
</network-security-config>
```
&emsp;&emsp;这段配置文件的意思是允许以明文的方式在网络上传递数据，**HTTP** 使用的就是明文传输方式。  

3. 修改```AndroidManifest.xml```启用配置文件  
```xml
<application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:networkSecurityConfig="@xml/network_config"
        android:theme="@style/AppTheme">
 ......
```
![图片示例](https://github.com/gneL1/AndroidStudy/blob/master/photos/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/XML_Pull.PNG)

***

### 2. SAX解析
* 新建一个类继承自```DefaultHandler```，并重写父类的5个方法。  
```startDocument()```在开始```XML```解析的时候调用。  
```startElement()```在开始解析某个节点的时候调用。  
```characters()```在获取节点中内容的时候调用，可能会被调用多次，一些换行符也被当作内容解析出来。  
```endElement()```在完成解析某个节点的时候调用。  
```endDocument()```在完成整个```XML```解析的时候调用。  
```kotlin

```


